\chapter{Naturali, Somma disgiunta e Liste}
\label{naturali-somma-disgiunta-liste}
%%dalla lezione 12 alle lezione 15 inclusa

\section{Tipo dei numeri Naturali}
\label{sec: tipo-naturali}

\subsection{Regole di Formazione}
\label{subsec: formazione-nat}
\begin{prooftree}
\AxiomC{$\Gamma$ cont}
\LeftLabel{F-Nat)}
\UnaryInfC{Nat type[$\Gamma$]}
\end{prooftree}

\subsection{Regole di Introduzione}
\label{subsec: eliminazione-nat}
\begin{center}
\AxiomC{$\Gamma$ cont}
\LeftLabel{I$_1$-Nat)}
\UnaryInfC{0 $\in$ Nat[$\Gamma$]}
\DisplayProof \qquad
\AxiomC{m $\in$ Nat[$\Gamma$]}
\LeftLabel{I$_2$-Nat)}
\UnaryInfC{succ(m) $\in$ Nat[$\Gamma$]}
\DisplayProof
\end{center}

\subsection{Regole di Eliminazione}
\label{subsec: eliminazione-nat}
\small
\begin{prooftree}
\AxiomC{t $\in$ Nat[$\Gamma$]}
\AxiomC{M(z) type[$\Gamma$, z $\in$ Nat]}
\AxiomC{c $\in$ M(0)[$\Gamma$]}
\AxiomC{e(x,y) $\in$ M(succ(x))[$\Gamma$, x $\in$ Nat, y $\in$ M(x)]}
\LeftLabel{E-Nat)}
\QuaternaryInfC{El$_{Nat}$(t,c,e) $\in$ M(t)[$\Gamma$]}
\end{prooftree}

\subsection{Regole di Conversione}
\label{subsec: conversione-nat}
\small
\begin{prooftree}
\AxiomC{M(z) type[$\Gamma$, z $\in$ Nat]}
\AxiomC{c $\in$ M(0)[$\Gamma$]}
\AxiomC{e(x,y) $\in$ M(succ(x))[$\Gamma$, x $\in$ Nat, y $\in$ M(x)]}
\LeftLabel{C$_1$-Nat)}
\TrinaryInfC{El$_{Nat}$(0,c,e) = c $\in$ M(0)[$\Gamma$]}
\end{prooftree}

\begin{prooftree}
\AxiomC{m  $\in$ Nat[$\Gamma$]}
\AxiomC{M(z) type[$\Gamma$, z $\in$ Nat]}
\AxiomC{c $\in$ M(0)[$\Gamma$]}
\AxiomC{e(x,y) $\in$ M(succ(x))[$\Gamma$, x $\in$ Nat, y $\in$ M(x)]}
\LeftLabel{C$_2$-Nat)}
\QuaternaryInfC{El$_{Nat}$(succ(m),c,e) = e(m, El$_{Nat}$(m,c,e)) $\in$ M(succ(m))[$\Gamma$]}
\end{prooftree}

\subsection{Regole di Uguaglianza}
\label{subsec: uguaglianza-nat}
\normalsize
\begin{center}
\begin{prooftree}
\AxiomC{t$_1$ = t$_2$ $\in$ Nat[$\Gamma$]}
\LeftLabel{eq-Nat)}
\UnaryInfC{succ(t$_1$) = succ(t$_2$) $\in$ Nat[$\Gamma$]}
\end{prooftree}
\end{center}

\subsection{Introduzione ed eliminatore dipendente}
\label{subsec:introduzione-eliminatore dipendente-naturale}
Le regole di formazione dei tipi e dei loro termini sono formulate in modo da rendere la regole si sostituzione per tipi e termini ammissibili.\\
Ad esempio la regola di introduzione del successore di un numero naturale si pu\`o formulare come un esplicito programma funzionale visto come termine dipendente.
\begin{prooftree}
\AxiomC{$\Gamma$ cont}
\LeftLabel{I$_2$-Nat$_{prog}$)}
\UnaryInfC{succ(x) $\in$ Nat[$\Gamma$, x $\in$ Nat]}
\end{prooftree}
Il medesimo discorso vale per la regola di eliminazione
\begin{prooftree}
\AxiomC{M(z) type[$\Gamma$, z $\in$ Nat]}
\AxiomC{c $\in$ M(0)[$\Gamma$]}
\AxiomC{e(x,y) $\in$ M(succ(x))[$\Gamma$, x $\in$ Nat, y $\in$ M(x)]}
\LeftLabel{E-Nat$_{dip}$)}
\TrinaryInfC{El$_{Nat}$(w,c,e) $\in$ M(t)[$\Gamma$, w $\in$ Nat]}
\end{prooftree}
\noindent
\textit{E-Nat} \`e equivalente a \textit{E-Nat$_{dip}$}. Difatti la teoria \textit{T$_{N1Nat}$}, in cui c'\`e \textit{E-Nat}, \`e equivalente a \textit{T$\backprime$} senza \textit{E-Nat}, ma con \textit{E-Nat$_{dip}$}, le regole di sosituzione e di \textit{sanitary check}.

\subsection{Primitiva ricorsiva}
\label{subsec: primitiva-ricorsiva}
\textit{Definizione}\\\\
Nat$^n$ $\times$ Nat $\rightarrow$ Nat\\
Dati g$_0$: Nat$^m$ $\rightarrow$ Nat e g$_1$: Nat$^m$ $\times$ Nat $\times$ Nat $\rightarrow$ Nat\\
n$_1$...n$_m$ $\in$ Nat allora\\\\
rec(n$_1$...n$_m$, 0) $\equiv$ g$_0$(n$_1$...n$_m$)\\
rec(n$_1$...n$_m$, k+1) $\equiv$ g$_0$(n$_1$...n$_m$, k, rec(n$_1$...n$_m$, k))

\subsection{Semantica operazionale dei numeri naturali}
\label{subsec: semantica-operazionale-naturali}
La relazione $\rightarrow_1$ viene definita all'interno dei termini con l'uso delle seguenti regole di riduzione:
\begin{itemize}
\item $\beta_{1Nat}$-red) El$_{Nat}$(0, c, e) $\rightarrow_1$ c
\item $\beta_{2Nat}$-red) El$_{Nat}$(succ(m), c, e) $\rightarrow_1$ e(m,El$_{Nat}$(m, c, e))
\item \AxiomC{t$_1$ $\rightarrow_1$ t$_2$}
\LeftLabel{red$_I$)}
\UnaryInfC{El$_{N1}$(t$_1$, c, e) $\rightarrow_1$ El$_{N1}$(t$_2$, c, e)}
\DisplayProof \qquad
\AxiomC{c$_1$ $\rightarrow_1$ c$_2$}
\LeftLabel{red$_{II}$)}
\UnaryInfC{El$_{N1}$(t, c$_1$, e) $\rightarrow_1$ El$_{N1}$(t, c$_2$, e)}
\DisplayProof 
\item Novit\`a dei numeri naturali rispetto al tipo singoletto
\AxiomC{t$_1$ $\rightarrow_1$ t$_2$}
\LeftLabel{N-red)}
\UnaryInfC{succ(t$_1$) $\rightarrow_1$ succ(t$_2$)}
\DisplayProof
\item + riduzione $\rightarrow_1$ rispetto a N$_1$
\end{itemize}

\subsection{Addizione per ricorsione}
\label{subsec: addizione-per-ricorsione}
\textit{Di seguito riporto un esercizio, svolto in aula, con lo scopo di comprendere come l'uguaglianza definizionale, tra numeri naturali, non coincide con l'uguaglianza aritmetica in matematica.}
\\\\
La somma, tra numeri naturali, viene definita usando l'eliminatore dipendente \textit{E-Nat$_{dip}$}(\S \ref{subsubsec:osservazioni-naturali}). In questo modo si riesce a definire per la nostra teoria \textit{T$_{1Nat}$}
\begin{center} w + z $\in$ Nat [w $\in$ Nat, z $\in$ Nat] \\ come \\ El$_{Nat}$(z, w, (x,y).succ(y))[w $\in$ Nat, z $\in$ Nat]\end{center}
Usando la nozione di primitava ricorsiva e decidendo di ricorrere su z \begin{center} w + 0 $\equiv$ w \\ w + succ(z) $\equiv$ succ(w+z) $\equiv$ succ(y)\end{center}
Ecco che l'albero di derivazione assume la seguente forma:
\scriptsize
\begin{adjustwidth}{-11em}{}
\begin{prooftree}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(w $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{w $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[w $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{(z $\in$ Nat) $\notin$ w $\in$ Nat}
\UnaryInfC{w $\in$ Nat, z $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[w $\in$ Nat, z $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(w $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{w $\in$ Nat cont}
\LeftLabel{var}
\UnaryInfC{w $\in$ Nat[w $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(w $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{w $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[w $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{\begin{tabular}[c]{cc}(z $\in$ Nat) $\notin$ \\ w $\in$ Nat \end{tabular}}
\UnaryInfC{w $\in$ Nat, z $\in$ Nat cont}
\LeftLabel{I$_2$-Nat$_{prog}$}
\UnaryInfC{succ(y) $\in$ [w $\in$ Nat, z $\in$ Nat, y $\in$ Nat]}
\LeftLabel{E-Nat$_{dip}$}
\TrinaryInfC{El$_{Nat}$(z, w, (x,y).succ(y))[w $\in$ Nat, z $\in$ Nat]}
\end{prooftree}
\end{adjustwidth}
\noindent
\normalsize
\begin{itemize}
\item Prova induttiva (minimo dei controlli da fare per verificare l'esattezza della derivazione)
\begin{itemize}
\item Caso base: cosa accade se poniamo al posto di z lo 0?\\
El$_{Nat}$(0, w, (x,y).succ(y)) $\rightarrow_1$ w per \textit{$\beta_{1Nat}$-red} ($\equiv$ w + 0 = w)
\item Passo induttivo: ricorro su z (esempio succ(0) = 1)\\
El$_{Nat}$(succ(0), w, (x,y).succ(y)) per \textit{$\beta_{1Nat}$-red} $\rightarrow_1$ succ(El$_{Nat}$(0, w, (x,y).succ(y))) $\rightarrow_1$ succ(w) \\
Dunque w + 1 = succ(w) $\in$ Nat
\end{itemize}
\noindent
$\Rightarrow$ Il programma fa effettivamente quello che dovrebbe.
\end{itemize}

\subsubsection{Osservazioni sull'addizione}
\label{subsubsec: osservazioni-addizione}
w $+_1$ z $\equiv$ El$_{Nat}$(z, w, (x,y), succ(y)) $\neq$ come NF da z.\\
Se sostituisco w con 0, allora 0 $+_1$ z $\equiv$ w $+_1$ z[$\frac{w}{0}$] $\equiv$ El$_{Nat}$(z, 0, (x,y), succ(y)) \`e in NF (dunque non riesco pi\`u a ridurla ulteriormente). 
\\Ecco che 0 $+_1$ z \`e un valore in NF $\neq$ da z, da cui \`e impossibile dimostrare che 0 $+_1$ z = z $\in$ Nat[z $\in$ Nat].\\
Questo non accade per w $+_1$ 0 = w (\S \ref{subsec: addizione-per-ricorsione}).\\ 
Perci\`o, se noi scriviamo la somma riccorrendo sul secondo membro, riusciamo a dire che \textit{primo-membro $+_1$ 0 = primo-membro}, ma non che \textit{0 $+_1$ secondo-membro = secondo - membro}. In quanto non esiste alcuna sottostrategia deterministica, per il secondo caso, per cui il programma si ferma.
\\\\
In conclusione, l'uguaglianza definizionale di termini con variabili \`e diversa dall'uguaglianza aritmentica. Eccezione fatta per le espressioni chiuse, senza variabili, perch\`e il termine chiuso si riduce a un'unica NF, che si dimostra essere un numero arabico.

\section{Tipo delle liste di un tipo}
\label{sec: tipo-delle-liste-di-un-tipo}
Il tipo delle liste di elementi costruisce un costruttore delle liste ed \`e definito dalle regole seguenti.

\subsection{Regole di Formazione}
\label{subsec: formazione-liste}
\begin{prooftree}
\AxiomC{A type [$\Gamma$]}
\LeftLabel{F-cost)}
\UnaryInfC{List(A)type [$\Gamma$]}
\end{prooftree}

\subsection{Regole di Introduzione}
\label{subsec: introduzione-liste}
\begin{center}
\AxiomC{list(A) type [$\Gamma$]}
\LeftLabel{I$_1$-list)}
\UnaryInfC{nil $\in$ List(A)[$\Gamma$]}
\DisplayProof \qquad
\AxiomC{s $\in$ List(A)[$\Gamma$]}
\AxiomC{a $\in$ A[$\Gamma$]}
\LeftLabel{I$_2$-list)}
\BinaryInfC{cons(s,a) $\in$ List(A)[$\Gamma$]}
\DisplayProof
\end{center}

\subsection{Regole di Eliminazione}
\label{subsec: eliminazione-liste}
\small
\begin{adjustwidth}{-7em}{}
\begin{prooftree}
\AxiomC{\begin{tabular}[c]{ccc}M(z) type[$\Gamma$, z $\in$ List(A)]\\t $\in$ List(A)[$\Gamma$] \\c $\in$ M(nil)[$\Gamma$]\end{tabular}}
\AxiomC{e(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A),  w $\in$ A, y $\in$ M(x)]}
\LeftLabel{E-List)}
\BinaryInfC{El$_{list}$(t,c,e) $\in$ M(t)[$\Gamma$]}
\end{prooftree}
\end{adjustwidth}

\subsection{Regole di Conservazione}
\label{subsec: conservazione-liste}
\small
\begin{adjustwidth}{-5em}{}
\begin{prooftree}
\AxiomC{\begin{tabular}[c]{cc}M(z) type[$\Gamma$, z $\in$ List(A)] \\ c $\in$ M(nil)[$\Gamma$]\end{tabular}}
\AxiomC{e(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A),  w $\in$ A, y $\in$ M(x)]}
\LeftLabel{C$_1$-list)}
\BinaryInfC{El$_{list}$(nil,c,e) = c $\in$ M(nil)[$\Gamma$]}
\end{prooftree}
\end{adjustwidth}
\small
\begin{adjustwidth}{-12em}{}
\begin{prooftree}
\AxiomC{M(z) type[$\Gamma$, z $\in$ List(A)]}
\AxiomC{\begin{tabular}[c]{ccc} s $\in$ List(A)[$\Gamma$] \\ a $\in$ A[$\Gamma$] \\ c $\in$ M(nil)[$\Gamma$]\end{tabular}}
\AxiomC{e(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A), w $\in$ A, y $\in$ M(x)]}
\LeftLabel{C$_2$-list)}
\TrinaryInfC{El$_{list}$(cons(s,a),c,e) = e(s,a, E$_{list}$(s,c,e) $\in$ M(cons(s,a))[$\Gamma$]}
\end{prooftree}
\end{adjustwidth}


\subsection{Regole di Uguaglianza}
\label{subsec: uguaglianza-liste}
\normalsize
\AxiomC{A$_1$ = A$_2$ $\in$ type[$\Gamma$]}
\LeftLabel{eq-I$_1$-List)}
\UnaryInfC{List(A$_1$) = List(A$_2$) type($\Gamma$)}
\DisplayProof  \\
\AxiomC{s$_1$ = s$_2$ $\in$ List(A)[$\Gamma$]}
\AxiomC{a$_1$ = a$_2$ $\in$ A[$\Gamma$]}
\LeftLabel{eq-I$_2$-List)}
\BinaryInfC{cons(s$_1$,a$_1$) = cons(s$_2$,a$_2$) $\in$ List(A)($\Gamma$)}
\DisplayProof
\small
\begin{adjustwidth}{-10em}{}
\begin{prooftree}
\AxiomC{\begin{tabular}[c]{ccc} M(z) type[$\Gamma$, z $\in$ List(A)] \\ t$_1$ = t$_2$ $\in$ list(A)[$\Gamma$] \\ c$_1$ = c$_2$ $\in$ M(nil)[$\Gamma$]\end{tabular}}
\AxiomC{e$_1$(x,w,y) = e$_2$(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A), w $\in$ A, y $\in$ M(x)]}
\LeftLabel{E-eq-List)}
\BinaryInfC{El$_{list}$(t$_1$, c$_1$, e$_1$) = El$_{list}$(t$_2$, c$_2$, e$_2$ $\in$ M(t$_1$)[$\Gamma$]}
\end{prooftree}
\end{adjustwidth}
\normalsize
\subsection{Eliminatore dipendente}
\label{subsec:eliminatore dipendente-lista}
L'eliminatore ha anche la forma dipendente, conveniente da usare soprattutto per motivi pratici.
\small
\begin{adjustwidth}{-7em}{}
\begin{prooftree}
\AxiomC{M(z) type[$\Gamma$, z $\in$ List(A)]}
\AxiomC{c $\in$ M(nil)[$\Gamma$]}
\AxiomC{e(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A),  w $\in$ A, y $\in$ M(x)]}
\LeftLabel{E-List$_{dip}$)}
\TrinaryInfC{El$_{list}$(z,c,e) $\in$ M(z)[$\Gamma$, z $\in$ List(A)]}
\end{prooftree}
\end{adjustwidth}
Quando si scrive un programma \'e bene scrivere la sostituzione espressamente, come riporto sotto.
\small
\begin{adjustwidth}{-7em}{}
\begin{prooftree}
\AxiomC{D type[$\Gamma$, z $\in$ List(A)]}
\AxiomC{c $\in$ D($\frac{z}{nil}$)[$\Gamma$]}
\AxiomC{e(x,w,y) $\in$ M($\frac{z}{cons(x,w)}$)[$\Gamma$, x $\in$ List(A),  w $\in$ A, y $\in$ D($\frac{z}{x}$)]}
\LeftLabel{E-List$_{dip}$)}
\TrinaryInfC{El$_{list}$(z,c,e) $\in$ M(z)[$\Gamma$, z $\in$ List(A)]}
\end{prooftree}
\end{adjustwidth}

\subsection{Semantica operazionale del tipo lista}
\label{subsec: semantica-operazionale-lista}
La relazione $\rightarrow_1$ viene definita all'interno dei termini con l'uso delle seguenti regole di riduzione:
\begin{itemize}
\item $\beta_{1list}$-red) El$_{list}$(nil, c, e) $\rightarrow_1$ c
\item $\beta_{2list}$-red) El$_{list}$(cons(s,a), c, e) $\rightarrow_1$ e(s,a,El$_{list}$(s, c, e))
\item \AxiomC{t$_1$ $\rightarrow_1$ t$_2$}
\LeftLabel{red$_I$)}
\UnaryInfC{El$_{list}$(t$_1$, c, e) $\rightarrow_1$ El$_{list}$(t$_2$, c, e)}
\DisplayProof \qquad
\AxiomC{c$_1$ $\rightarrow_1$ c$_2$}
\LeftLabel{red$_{II}$)}
\UnaryInfC{El$_{list}$(t, c$_1$, e) $\rightarrow_1$ El$_{list}$(t, c$_2$, e)}
\DisplayProof 
\item Novit\`a delle liste rispetto al tipo singoletto
\AxiomC{s$_1$ $\rightarrow_1$ s$_2$}
\LeftLabel{L-red$_I$)}
\UnaryInfC{cons(s$_1$,a) $\rightarrow_1$ cons(s$_2$,a)}
\DisplayProof
\item \AxiomC{a$_1$ $\rightarrow_1$ a$_2$}
\LeftLabel{L-red$_{II}$)}
\UnaryInfC{cons(s,a$_1$) $\rightarrow_1$ cons(s,a$_2$)}
\DisplayProof
\item + riduzione $\rightarrow_1$ rispetto a N$_1$
\end{itemize}

\section{Esercizi}
\label{sec:esercizi-cap3}

\subsection{Tipo dei numeri Naturali}
\label{subsec: naturali}
\paragraph{1}
\textbf{Dimostrare che le regole enunciate in \S\ref{sec: tipo-naturali}, \textit{I$_2$-Nat$_{prog}$} ed \textit{E-Nat$_{prog}$}, sono ammissibili nel sistema di teoria dei tipi dei numeri naturali.}
\\\\
\textbf{Soluzione}\\\\
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma$ count}
\LeftLabel{I$_1$-Nat}
\UnaryInfC{0 $\in$ Nat[$\Gamma]$}
\LeftLabel{I$_2$-Nat}
\UnaryInfC{$\vdots$}
\LeftLabel{I$_2$-Nat}
\UnaryInfC{x-1 $\in$ Nat[$\Gamma]$}
\LeftLabel{I$_2$-Nat}
\UnaryInfC{x $\in$ Nat[$\Gamma]$}
\LeftLabel{I$_2$-Nat}
\UnaryInfC{succ(x) $\in$ Nat[$\Gamma$]}
\AxiomC{}
\UnaryInfC{$\Gamma$ count}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[$\Gamma$]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ $\Gamma$}
\UnaryInfC{$\Gamma$, x $\in$ Nat cont}
\LeftLabel{ind-te}
\BinaryInfC{succ(x) $\in$ Nat[$\Gamma$, x $\in$ Nat]}
\end{prooftree}
\noindent
\normalsize{Assumo che le premesse di \textit{I$_2$-Nat$_{prog}$} (\textit{$\Gamma$ count}) sia valida, p\`erci\`o \`e valido, dalla prova sopra, anche il giudizio di conclusione \textit{succ(x) $\in$ Nat[$\Gamma$, x $\in$ Nat]}, di conseguenza derivabile in \textit{T}.}


\begin{prooftree}
\AxiomC{}
\UnaryInfC{El$_{Nat}$(t,c,e) $\in$ M(t)[$\Gamma$, w $\in$ Nat, t $\in$ Nat]}
\AxiomC{[ ] cont}
\UnaryInfC{$\vdots$}
\UnaryInfC{$\Gamma$ count}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[$\Gamma$]}
\LeftLabel{F-c}\RightLabel{(w $\in$ Nat) $\notin$ $\Gamma$}
\UnaryInfC{$\Gamma$, w $\in$ Nat cont}
\LeftLabel{var}
\UnaryInfC{w $\in$ Nat[$\Gamma$, w $\in$ Nat]}
\LeftLabel{sub-ter}
\BinaryInfC{El$_{Nat}$(w,c,e) $\in$ M(t)[$\Gamma$, w $\in$ Nat]}
\end{prooftree}
\noindent
\normalsize{Assumo che le premesse di \textit{I$_E$-Nat$_{prog}$} (\textit{M(z) type[$\Gamma$, z $\in$ Nat], c $\in$ M(0)[$\Gamma$], e(x,y) $\in$ M(succ(x))[$\Gamma$, x $\in$ Nat, y $\in$ M(x)]}) sia valida, p\`erci\`o \`e valido, dalla prova sopra, anche il giudizio di conclusione \textit{El$_{Nat}$(w,c,e) $\in$ M(t)[$\Gamma$, w $\in$ Nat]}, di conseguenza derivabile in \textit{T}.}

\paragraph{2}
\textbf{Definire w + 2 $\in$ Nat[w $\in$ Nat], ove 2 \`e l'abbreviazione del termine ottenuto applicando 2 $\equiv$ succ(succ(0)).}
\\\\
\textbf{Soluzione}\\\\
La ricorsione la faccio w, usando lo schema di ricorsione primitva, vale che w + 2 $\equiv$ El$_{Nat}$(w, 2, (x,y).succ(y)) $\in$ Nat[w $\in$ Nat]

\small
\begin{adjustwidth}{-10em}{}
\begin{prooftree}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[ ]}
\LeftLabel{F-c}\RightLabel{(w $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{w $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[w $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{I$1$-Nat}
\UnaryInfC{0 $\in$ Nat[ ]}
\LeftLabel{I$2$-Nat}
\UnaryInfC{1 $\in$ Nat[ ]}
\LeftLabel{I$2$-Nat}
\UnaryInfC{2 $\in$ Nat[ ]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{x $\in$ Nat cont}
\LeftLabel{I$2$-Nat$_{prog}$}
\UnaryInfC{succ(y) $\in$ Nat[x $\in$ Nat, y $\in$ Nat]}
\LeftLabel{E-Nat$_{dip}$}
\TrinaryInfC{El$_{Nat}$(w, 2, (x,y).succ(y)) $\in$ Nat[w $\in$ Nat]}
\end{prooftree}
\end{adjustwidth}
\noindent
\normalsize \textit{Dimostrazione di correttezza di El$_{Nat}$(w, 2, (x,y).succ(y)) $\in$ Nat[w $\in$ Nat]}
\begin{itemize}
\item El$_{Nat}$(0, 2, (x,y).succ(y)) $\rightarrow_1$ 2 per \textit{$\beta_{1Nat}$-red}
\item El$_{Nat}$(succ(m), 2, (x,y).succ(y)) $\rightarrow_1$ succ(El$_{Nat}$(m, 2, (x,y).succ(y))) per \textit{$\beta_{2Nat}$-red} $\Rightarrow$ per m = 0 $\equiv$ succ(El$_{Nat}$(0, 2, (x,y).succ(y))) $\rightarrow_1$ succ(2) $\in$ Nat = 3 (dal punto precedente).
\end{itemize}

\paragraph{3}
\textbf{Definire l'operazione di addizione usando le regole del tipo dei numeri naturali.}
\begin{center} x + y $\in$ Nat[x $\in$ Nat, y $\in$ Nat\end{center}
in modo tale che valga x + 0 = x $\in$  Nat[x $\in$ Nat]
\\\\
\textbf{Soluzione}\\\\
La ricorsione la faccio y, usando lo schema di ricorsione primitva, vale che x + y $\equiv$ El$_{Nat}$(y, x, (w,z).succ(z)) $\in$ Nat[x $\in$ Nat, y $\in$ Nat]


\scriptsize
\begin{adjustwidth}{-10em}{}
\begin{prooftree}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{x $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[x $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{\begin{tabular}[c]{cc}(y $\in$ Nat) $\notin$ \\ x $\in$ Nat \end{tabular}}
\UnaryInfC{x $\in$ Nat, y $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[x $\in$ Nat, y $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{x $\in$ Nat cont}
\LeftLabel{var}
\UnaryInfC{x $\in$ Nat[x $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[ ]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{x $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[x $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{\begin{tabular}[c]{ccc}(w $\in$ Nat) \\ $\notin$ x $\in$ Nat \end{tabular}}
\UnaryInfC{x $\in$ Nat, w $\in$ Nat cont}
\LeftLabel{I$_{2}$-Nat$_{prog}$}
\UnaryInfC{succ(z) $\in$ Nat[x $\in$ Nat, w $\in$ Nat, z $\in$ Nat]}
\LeftLabel{E-Nat$_{dip}$}
\TrinaryInfC{El$_{Nat}$(y, x, (w,z).succ(z)) $\in$ Nat[x $\in$ Nat, y $\in$ Nat]}
\end{prooftree}
\end{adjustwidth}
\noindent
\normalsize \textit{Dimostrazione di correttezza di El$_{Nat}$(y, x, (w,z).succ(z)) $\in$ Nat[x $\in$ Nat, y $\in$ Nat]}
\begin{itemize}
\item El$_{Nat}$(0, x, (w,z).succ(z))  $\rightarrow_1$ x per \textit{$\beta_{1Nat}$-red}
\item El$_{Nat}$(succ(y), x, (w,z).succ(z)) $\rightarrow_1$ succ(El$_{Nat}$(y, x, (w,z).succ(z))) per \textit{$\beta_{2Nat}$-red} $\Rightarrow$ per y=0 $\equiv$ succ(El$_{Nat}$(0, x, (w,z).succ(z))) $\rightarrow_1$ succ(x) $\in$ Nat = x + 1  (dal punto precedente).
\end{itemize}

\paragraph{4}
\textbf{Definire l'operazione di addizione usando le regole del tipo dei numeri naturali.}
\begin{center} x + y $\in$ Nat[x $\in$ Nat, y $\in$ Nat\end{center}
in modo tale che valga 0 + y = x $\in$  Nat[x $\in$ Nat]
\\\\
\textbf{Soluzione}\\\\
La ricorsione la faccio x, percui, usando lo schema di ricorsione primitva, vale che x + y $\equiv$ El$_{Nat}$(x, y, (w,z).succ(z)) $\in$ Nat[x $\in$ Nat, y $\in$ Nat]

\small
\begin{adjustwidth}{-6em}{}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{El$_{Nat}$(x, y, (w,z).succ(z)) $\in$ Nat[y $\in$ Nat, x $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{x $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[x $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{(y $\in$ Nat) $\notin$ x $\in$ Nat}
\UnaryInfC{x $\in$ Nat, y $\in$ Nat cont}
\LeftLabel{ex-te}
\BinaryInfC{El$_{Nat}$(x, y, (w,z).succ(z)) $\in$ Nat[x $\in$ Nat, y $\in$ Nat]}
\end{prooftree}
\end{adjustwidth}

\scriptsize
\begin{adjustwidth}{-11em}{}
\begin{prooftree}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[ ]}
\LeftLabel{F-c}\RightLabel{(y $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{y $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [y $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{(x $\in$ Nat) $\notin$ y $\in$ Nat}
\UnaryInfC{y $\in$ Nat, x $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[y $\in$ Nat, x $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(y $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{y $\in$ Nat cont}
\LeftLabel{var}
\UnaryInfC{y $\in$ Nat[y $\in$ Nat]}
\AxiomC{[ ] cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type [ ]}
\LeftLabel{F-c}\RightLabel{(y $\in$ Nat) $\notin$ [ ]}
\UnaryInfC{y $\in$ Nat cont}
\LeftLabel{F-Nat}
\UnaryInfC{Nat type[y $\in$ Nat]}
\LeftLabel{F-c}\RightLabel{\begin{tabular}[c]{cc}(w $\in$ Nat) $\notin$ \\ y $\in$ Nat \end{tabular}}
\UnaryInfC{y $\in$ Nat, w $\in$ Nat cont}
\LeftLabel{I$_2$-Nat$_{prog}$}
\UnaryInfC{succ(z) $\in$[y $\in$ Nat, w $\in$ Nat, z $\in$ Nat]}
\LeftLabel{E-Nat$_{dip}$}
\TrinaryInfC{El$_{Nat}$(x, y, (w,z).succ(z)) $\in$ Nat[y $\in$ Nat, x $\in$ Nat]}
\end{prooftree}
\end{adjustwidth}
\noindent\\
\normalsize \textit{Dimostrazione di correttezza di El$_{Nat}$(x, y, (w,z).succ(z)) $\in$ Nat[y $\in$ Nat, x $\in$ Nat]}
\begin{itemize}
\item El$_{Nat}$(0, y, (w,z).succ(z))  $\rightarrow_1$ y per \textit{$\beta_{1Nat}$-red}
\item El$_{Nat}$(succ(x), y, (w,z).succ(z)) $\rightarrow_1$ succ(El$_{Nat}$(x, y, (w,z).succ(z))) per \textit{$\beta_{2Nat}$-red} $\Rightarrow$ per x=0 $\equiv$ succ(El$_{Nat}$(0, y, (w,z).succ(z))) $\rightarrow_1$ succ(y) $\in$ Nat = y + 1  (dal punto precedente).
\end{itemize}

\subsection{Tipo delle liste}
\label{subsec: liste}
\paragraph{1}
\textbf{Dati i tipi singoletto e delle liste \`e possibile definire un tipo dei numeri naturali \textit{Nat}?}
\\\\
\textbf{Soluzione}\\\\
Posso vedere una lista come una collezione di n singoletti. Ecco che posso definire il tipo dei numeri naturali su questa lista, per ricorsione primitiva, nel modo sottostante:
\begin{center}
0 = nil \\
1 = cons(nil, $\ast$) \\
n = cons(cons(n-1), $\ast$)
\end{center}

\paragraph{2}
\textbf{Dato un tipo A semplice, ovvero non dipendente, per esempio A = N{$_1$}, se si vuole definire un'operazione \begin{center} append$_1$(x$\backprime$,y$\backprime$) $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ A]\end{center}
\noindent tale che l'elemento y$\backprime$ venga posto alla fine della lista x$\backprime$, allora basta definire append$_1$ nel modo seguente \begin{center}append$_1$(x$\backprime$,y$\backprime$) = cons(x$\backprime$,y$\backprime$) $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ A]\end{center}
\noindent Ma se si vuole definire un'operazione \begin{center} append$_2$(x$\backprime$,y$\backprime$) $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ A]\end{center} 
\noindent tale che y$\backprime$ venga posto all'inizio della lista x$\backprime$ ,allora come occorre procedere?.}\\\\
\textbf{Soluzione} (\textit{Procedimento preso dalle note})
\\\\
Per riuscire a porre y$\backprime$ all'inizio della lista x$\backprime$, devo usare la regola di eliminazione sulla lista x$\backprime$. Per farlo, devo prima di tutto definire equazionalmente la definizione ricorsiva di append$_2$
\begin{center}
append$_2$(nil, y$\backprime$) =  cons(nil, y$\backprime$) = y$\backprime$\\
append$_2$(cons(s, x$\backprime$), y$\backprime$) = cons(append$_2$(s, y$\backprime$), x$\backprime$)\\
\end{center}
Ora posso applicare la regola dell'eliminazione nel modo seguente:
\begin{itemize}
\item Premesse:
\begin{itemize}
\item M(z) type[$\Gamma$, z $\in$ List(A)] $\equiv$ List(A) type[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ List(A)]
\item t $\in$ List(A)[$\Gamma$] $\equiv$ x$\backprime$ $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ List(A)]
\item c $\in$ M(nil)[$\Gamma$] $\equiv$ y$\backprime$ $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ List(A)]
\item e(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A),  w $\in$ A, y $\in$ M(x)] $\equiv$
cons(z,y) $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ List(A), z $\in$ List(A), y$\in$ A]
\end{itemize}
\noindent
\item Giudizio di conclusione:
\begin{itemize}
\item El$_{list}$(t,c,e) $\in$ M(t)[$\Gamma$] $\equiv$ El$_{list}$(x$\backprime$, y$\backprime$,(x,y,z).cons(z,y)) $\in$ List(A)[x$\backprime$ $\in$ List(A), y$\backprime$ $\in$ List(A)]
\end{itemize}
\end{itemize}



\paragraph{3}
\textbf{Definire l'operazione \textit{append} di accostamento di una lista a un'altra di tipo A type[ ] usando le regole del tipo delle liste
\begin{center}append(x,y) $\in$ List(A)[x $\in$ List(A), x $\in$ List(A)]\end{center}
in modo tale che valga append(x,nil) = x $\in$ List(A)[x $\in$ List(A)]
}

\textbf{Soluzione}
\\\\
Per riuscire a poter concatenare la lista x alla lista y, devo usare la regola di eliminazione sulla lista x. Per farlo, devo prima di tutto definire equazionalmente la definizione ricorsiva di append
\begin{center}
append(x, nil) =  cons(x, nil) = x\\
append(x, cons(y, a)) = cons(x, append(y, a))\\
\end{center}
Ora posso applicare la regola dell'eliminazione nel modo seguente:
\begin{itemize}
\item Premesse:
\begin{itemize}
\item M(z) type[$\Gamma$, z $\in$ List(A)] $\equiv$ List(A) type[x $\in$ List(A), y $\in$ List(A)]
\item t $\in$ List(A)[$\Gamma$] $\equiv$ y $\in$ List(A)[x $\in$ List(A), y $\in$ List(A)]
\item c $\in$ M(nil)[$\Gamma$] $\equiv$ x $\in$ List(A)[x $\in$ List(A), y $\in$ List(A)]
\item e(x,w,y) $\in$ M(cons(x,w))[$\Gamma$, x $\in$ List(A),  w $\in$ A, y $\in$ M(x)] $\equiv$
cons(z,w) $\in$ List(A)[x $\in$ List(A) y $\in$ List(A), z $\in$ List(A), w$\in$ A]
\end{itemize}
\noindent
\item Giudizio di conclusione:
\begin{itemize}
\item El$_{list}$(t,c,e) $\in$ M(t)[$\Gamma$] $\equiv$ El$_{list}$(y, x,(u,v,z).cons(z,v)) $\in$ List(A)[x $\in$ List(A), y $\in$ List(A)]
\end{itemize}
\end{itemize}

\begin{prooftree}
\AxiomC{}%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type [ ]}
%\LeftLabel{F-c}\RightLabel{(x $\in$ List(A)) $\notin$ [ ]}
%\UnaryInfC{x $\in$ List(A) cont}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{ind-ty}
%\BinaryInfC{A type[x $\in$ List(A)]}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type [ ]}
%\LeftLabel{F-c}\RightLabel{(x $\in$ List(A)) $\notin$ [ ]}
%\UnaryInfC{x $\in$ List(A) cont}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{ind-ty}
%\BinaryInfC{A type[x $\in$ List(A)]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type[x $\in$ List(A)]}
%\LeftLabel{F-c}\RightLabel{(y $\in$ List(A)) $\notin$ x $\in$ List(A)}
%\UnaryInfC{x $\in$ List(A), y $\in$ List(A) cont}
%\LeftLabel{ind-ty}
%\BinaryInfC{A type[x $\in$ List(A), y $\in$ List(A)]}
%\LeftLabel{F-cost}
\UnaryInfC{\textbf{1}}%\UnaryInfC{List(A) type[x $\in$ List(A), y $\in$ List(A)]}
\AxiomC{}%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type [ ]}
%\LeftLabel{F-c}\RightLabel{(x $\in$ List(A)) $\notin$ [ ]}
%\UnaryInfC{x $\in$ List(A) cont}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{ind-ty}
%\BinaryInfC{A type[x $\in$ List(A)]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type[x $\in$ List(A)]}
%\LeftLabel{F-c}\RightLabel{(y $\in$ List(A)) $\notin$ x $\in$ List(A)}
%\UnaryInfC{x $\in$ List(A), y $\in$ List(A) cont}
%\LeftLabel{var}
\UnaryInfC{\textbf{2}}%\UnaryInfC{y $\in$ List(A)[x $\in$ List(A), y $\in$ List(A)]}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type [ ]}
%\LeftLabel{F-c}\RightLabel{(x $\in$ List(A)) $\notin$ [ ]}
%\UnaryInfC{x $\in$ List(A) cont}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{ind-ty}
%\BinaryInfC{A type[x $\in$ List(A)]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type[x $\in$ List(A)]}
%\LeftLabel{F-c}\RightLabel{(y $\in$ List(A)) $\notin$ x $\in$ List(A)}
%\UnaryInfC{x $\in$ List(A), y $\in$ List(A) cont}
\AxiomC{}%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type [ ]}
%\LeftLabel{F-c}\RightLabel{(y $\in$ List(A)) $\notin$ [ ]}
%\UnaryInfC{y $\in$ List(A) cont}
%\AxiomC{[ ] cont}
%\LeftLabel{s-checks}
%\UnaryInfC{A type[ ]}
%\LeftLabel{ind-ty}
%\UnaryInfC{A type[y $\in$ List(A)]}
%\LeftLabel{F-cost}
%\UnaryInfC{List(A) type[y $\in$ List(A)]}
%\LeftLabel{F-c}\RightLabel{(x $\in$ List(A)) $\notin$ y $\in$ List(A)}
%\UnaryInfC{y $\in$ List(A), x $\in$ List(A) cont}
%\LeftLabel{var}
%\UnaryInfC{x $\in$ List(A)[y $\in$ List(A), x $\in$ List(A)]}
%\LeftLabel{ex-te}
\UnaryInfC{\textbf{3}}%\BinaryInfC{x $\in$ List(A)[x $\in$ List(A), y $\in$ List(A)]}
\AxiomC{}
\UnaryInfC{\textbf{4}}%\UnaryInfC{cons(z,w) $\in$ List(A)[x $\in$ List(A) y $\in$ List(A), z $\in$ List(A), w$\in$ A]}
\LeftLabel{E-list}
\QuaternaryInfC{El$_{list}$(y, x,(u,v,z).cons(z,v)) $\in$ List(A)[x $\in$ List(A), y $\in$ List(A)}
\end{prooftree}