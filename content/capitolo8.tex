\chapter{Tipo delle funzioni}
\label{cap: funzioni}
%lezione 20
Il tipo delle funzione \`e definito dalle regole seguenti.

\section{Regole di Formazione}
\label{subsec: formazione-funzioni}
\begin{prooftree}
\AxiomC{B type [$\Gamma$]}
\AxiomC{C type [$\Gamma$]}
\LeftLabel{F-$\rightarrow$)}
\BinaryInfC{B $\rightarrow$ C type[$\Gamma$]}
\end{prooftree}

\section{Regole di Introduzione}
\label{subsec: introduzione-funzioni}
\begin{prooftree}
\AxiomC{c(x) $\in$ C[$\Gamma$,x $\in$ B]}
\LeftLabel{I-$\rightarrow$)}
\UnaryInfC{$\lambda$x$^B$.c(x) $\in$ B $\rightarrow$ C}
\end{prooftree}
\noindent
\textit{c \`e una meta-variabile, con il quale si indica un termine che pu\`o dipendere o meno da x}

\section{Regole di Eliminazione}
\label{subsec: eliminazione-funzione}
\begin{prooftree}
\AxiomC{f $\in$ B $\rightarrow$ C[$\Gamma$]}
\AxiomC{b $\in$ B[$\Gamma$]}
\LeftLabel{E-$\rightarrow$)}
\BinaryInfC{Ap(f,b) $\in$ C[$\Gamma$]}
\end{prooftree}
\noindent
\textit{Il tipo non \`e induttivo, per cui la regola di eliminazione non definisce un ricorsivo, n\`e principi di induzione}

\section{Regole di Conservazione}
\label{subsec: conservazione-funzione}
\begin{prooftree}
\AxiomC{c(x) $\in$ C[$\Gamma$, x $\in$ B]}
\AxiomC{b $\in$ B[$\Gamma$]}
\LeftLabel{C-$\rightarrow$)}
\BinaryInfC{Ap($\lambda$x$^B$.c(x),b] $=$ c(b)$\in$ C[$\Gamma$]}
\end{prooftree}

\section{Regole di Uguaglianza}
\label{subsec: uguaglianza-funzione}
\begin{prooftree}
\AxiomC{f$_1$ $=$ f$_2$ $\in$ B $\rightarrow$ C[$\Gamma$]}
\AxiomC{b$_1$ $=$ b$_2$ $\in$ B[$\Gamma$]}
\LeftLabel{eq-F-$\rightarrow$)}
\BinaryInfC{Ap(f$_1$,b$_1$) $=$ Ap(f$_2$,b$_2$) $\in$ C[$\Gamma$]}
\end{prooftree}

\begin{prooftree}
\AxiomC{c$_1$(x) $=$ c$_2$(x) $\in$ C[$\Gamma$,x $\in$ B]}
\LeftLabel{eq-I-$\rightarrow$)}
\UnaryInfC{$\lambda$x$^B$.c$_1$(x) $=$ $\lambda$x$^B$x.c$_2$ $\in$ B $\rightarrow$ C[$\Gamma$]}
\end{prooftree}
\normalsize
\textit{Prende anche il nome di $\xi$-rule ed \`e una regola difficile da modellare}


\section{Semantica operazionale del tipo funzione}
\label{subsec: semantica-operazionale-funzione}
La relazione $\rightarrow_1$ viene definita all'interno dei termini con l'uso delle seguenti regole di riduzione:
\begin{itemize}
\item $\beta_{\rightarrow}$-red) Ap($\lambda$x.c(x),b) $\rightarrow_1$ c(b) \\
\textit{Per la programmazione:} ($\lambda$x.c,b) $\rightarrow_1$ c[$\frac{x}{b}$] 
\item \AxiomC{f$_1$ $\rightarrow_1$ f$_2$}
\LeftLabel{$\rightarrow$-red$_1$)}
\UnaryInfC{Ap(f$_1$,b) $\rightarrow_1$ Ap(f$_2$,b)}
\DisplayProof \qquad
\item \AxiomC{b$_1$ $\rightarrow_1$ b$_2$}
\LeftLabel{$\rightarrow$-red$_2$)}
\UnaryInfC{Ap(f,b$_1$) $\rightarrow_1$ Ap(f,b$_2$)}
\DisplayProof
\item Novit\`a della somma indiciata forte rispetto al tipo singoletto
\AxiomC{c$_1$ $\rightarrow_1$ c$_2$}
\LeftLabel{$\rightarrow$-red)}
\UnaryInfC{$\lambda$x.c$_1$ $\rightarrow_1$ $\lambda$x.c$_2$}
\DisplayProof
\end{itemize}

\section{Osservazioni sulla regola di Introduzione}
\label{sec:osservazioni-introduzione-funzione}
\begin{prooftree}
\AxiomC{$\beta$ prop[$\Gamma$]}
\AxiomC{$\gamma$ prop[$\Gamma$]}
\LeftLabel{F-$\rightarrow$)}
\BinaryInfC{$\beta$ $\rightarrow$ $\gamma$ prop[$\Gamma$]}
\end{prooftree}
\noindent
Ove $\beta$ $\rightarrow$ $\gamma$ \`e un'implicazione logica.\\\\
\noindent 
$\beta$ $\rightarrow$ $\gamma$ \textit{(implicazione)} \quad $=$ \quad $\beta$ $\rightarrow$ $\gamma$ \textit{(tipo)}\\
Questo risulta vero perch\`e \textit(I-$\rightarrow$) afferma che se si ha
\begin{prooftree}
\AxiomC{c(x) $\in$ $\gamma$[$\Gamma$,$\Delta$,x $\in$ $\beta$]}
\LeftLabel{I-$\rightarrow$)}
\UnaryInfC{\cancel{$\lambda$x.c(x)} $\in$ $\beta$ $\rightarrow$ $\gamma$[$\Gamma$,$\Delta$]}
\end{prooftree}
\noindent
c(x) $\in$ $\gamma$ $\equiv$ $\gamma$ vero\\
x $\in$ $\beta$ $\equiv$ $\beta$ vero\\
$\beta$ $\rightarrow$ $\gamma$ $\equiv$ $\beta$ $\rightarrow$ $\gamma$ vero\\\\
\noindent
Che non \`e altro che la regola 
\begin{prooftree}
\AxiomC{$\varphi_1,..\varphi_n,\beta$ $\vdash_\Gamma$ $\gamma$}
\LeftLabel{$\rightarrow$-D)}
\UnaryInfC{$\varphi_1,..\varphi_n$ $\vdash_\Gamma$ $\beta \rightarrow \gamma$}
\end{prooftree}

