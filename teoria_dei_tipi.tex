\documentclass[10pt,a4paper, italian]{book}
\usepackage[italian]{babel}
\usepackage{amssymb}
\usepackage[table]{xcolor}
\usepackage{tabularx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=blue,
	urlcolor=linkcolor
}	
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bussproofs} % per alberi di deduzione naturale
\usepackage{graphicx}

\begin{document}
\begin{figure}[H]
\centering
  \includegraphics[width=0.6\linewidth]{./img/logo_dip.png}
   \label{fig: logo-unip-dipartimento-matematica}
\end{figure}
\begin{center}\Large{\textbf{Universit\`a degli Studi di Padova\\Dipartimento di Matematica "Tullio Levi-Civita\\Corso di Laurea Magistrale in Informatica}}\end{center}
\begin{center}\Large{Esame di Teoria dei Tipi}\end{center}
\begin{flushright} 
Teoria dei Tipi\\
\textit{Elaborato scritto - Settembre 2020}\\
Eleonora Signor, 1237581
\end{flushright}


\pagebreak

\tableofcontents \pagebreak

\chapter{Introduzione}
\label{cap:introduzione}
\section{La triplice faccia della teoria dei tipi}
\label{sec:la-triplice-faccia}
La teoria dei tipi offre una base teorica a fondamento dello sviluppo di:
\begin{itemize}
\item \textbf{Matematica}: nella teoria degli insiemi;
\item \textbf{Logica}: come fondamento dei connettivi logici e dei quantificatori, con trattazione mediate tecniche di \textit{proof-teory} per dimostrarne la non falsit\`a o non contradditoriet\`a;
\item \textbf{Informatica}: per la correttezza dei programmi, da una semantica operazionale a un certo tipo di operazioni.\\ 
Con riferimento alla teoria degli insiemi, visto come linguaggio di programmazione funzionale, \`e possibile specificare con formule l'obiettivo di un programma e dimostrarne la correttezza attraverso la specifica.
\end{itemize}
\noindent
La teoria dei tipi nasce per garantire la \textit{Certified Proof Correctness}. Ovvero la correttezza dei programmi, volta a costruire gli assistenti automatici per le formalizzazioni.

\section{Come nasce la teoria dei tipi}
\label{sec:come-nasce}
Gli errori di programmazione sono stati preponderanti alla nascita di metodi automatici, che assicurassero la correttezza del \textit{software}. Alcuni di questi, degni di nota, sono stati:
\begin{itemize}
\item Incidente nel lancio dell'Apollo 11;
\item Tragedie sanitarie: incidenti avvenuti tra il 1985-1987, in cui dei pazienti ricevettero una massiccia \textit{overdose} di radiazioni e per la quali alcuni morirono;
\item Errori di vita civile: riserva di solo due cifre per il campo et\`a all'interno dei \textit{database}. Ecco che una signora danese ricevette per il suo 107-esimo compleanno, una mail dalle autorit\`a della scuola locale per iscriversi alla prima elementare.
\end{itemize}
\noindent 
Per la matematica la correttezza delle dimostrazioni \`e irrilevante solo quando la soluzione \`e certa (come accade con il cubo di \textit{Rubik}, dove so che la soluzione \`e corretta quando ognuno dei lati \`e uniformemente colorato); e in generale questo \`e difficile che accada.\\
Un'esempio di problema, dove la soluzione non \`e certa, \`e il Teorema dei Quattro Colori, risolto da un \textit{computer} e la cui prova di correttezza della dimostrazione fu data dal \textit{proof assistant} Coq. Quest'ultimo basato sulla teoria dei tipi e intellegibile dall'essere umano.\\\\
Una citazione importante va al matematico Russo V.V. \textit{Voevodsky}, vincitore della medaglia \textit{ Fields}. Esso si batt\`e per la creazione di un \textit{proof assistant}, per rendere le dimostrazioni da informali, per problemi complessi, a completamente formalizzate, con l'impiego della teoria dei tipi. I suoi studi trovano principale applicazione in campo algebrico e geometrico; ma i concetti emersi assunsero delle 1connotazioni pi\`u ampie. \textit{Voevodsky}, difatti, si rese conto che formalizzare equivale a programmare. Ci\`o significa che la teoria dei tipi permette di vedere una dimostrazione come un programma.
\\\\
Esiste la certezza assoluta per una certa teoria, esclusivamente, quando ha un numero di assiomi, accettati per fede, molto limitato. In quanto assiomalizzabile da un calcolatore.
\\\\
In coclusione formalizzare in una teoria dei tipi (come quella degli insiemi) equivale a programmare un programma.

\section{Il Paradosso di Russell}
\label{sec:paradosso-di-russell}
La base della teoria dei tipi, compresa quella di \textit{Martin-L$\ddot{o}$f}, si deve a B. \textit{Russell}. \\
Siamo nel 1907 quando nasce la teoria dei tipi, sviluppata nei \textit{Principia Mathematica} da B. \textit{Russel} assieme ad A.N. \textit{Whitehead}. Tale teoria, intesa come logica e non informatica, nasce come soluzione alternativa alla teoria degli insiemi, di allora, con lo scopo di fondare la matematica su un sistema formale accettabile e non contradditorio.\\
Di seguito espongo un sistema contradditorio della teoria degli insiemi.\\
\\
\textbf{Linguaggio \textit{L} di una teoria degli insiemi \textit{F}}\mbox{}
\begin{itemize}
\item \textit{L} linguaggio del primo ordine (=, \&, $\rightarrow$, $\lor$, $\forall{x}$, $\exists{x}$), con l'aggiunta del predicato $\in$ "appartiene"
\item variabili VAR $\ni$ \{x, y, z, w,\dots \}
\end{itemize}
\noindent
dove x, y, z sono da intendersi come insiemi e x $\epsilon$ y = "x appartiene a y".\\\\
All'interno di \textit{L} c'\`e una teoria degli insiemi. Tra cui prende posto l'\textbf{assioma di comprensione di \textit{Frege}}, definito nel modo seguente:\\
Per ogni formula $\phi$(x) vale che $\exists$z $\forall$y (y$\in$z $\Leftrightarrow$ $\phi$(y)) [$\equiv$ $\exists$z z = \{x $\big|$ $\phi$(x)\}]\\\\
\textbf{Teorema (o Paradosso) di \textit{Russell}}: la teoria \textit{F} \`e contradditoria.\\

\noindent \textbf{Dimostrazione}:\\
$\phi$(x) = x$\notin$x ($\equiv$ $\neg$ (x $\in$ x))\\
Per l'assioma di comprensione	$\exists$z z = \{x $|$ x$\notin$x\} ($\exists$z $\forall$y (y$\in$z $\Leftrightarrow$ y$\notin$y))\\
Ponendo y=z ottengo che z$\in$z $\Leftrightarrow$ z$\notin$z, risulta una \textbf{contraddizione}.\\\\
L'assioma di comprensione \`e contradditorio perch\`e permette di formare insiemi che non appartengono a se stessi.\\\\
Come correggere la contraddizione?\\
La soluzione accettabile \`e porre agli insiemi una \textbf{gerarchia di tipi}. In questo modo l'assioma di comprensione diventa:\\
$\exists$z $\forall$y (y$\in$a $\to$ (y$\in$z $\Leftrightarrow$ $\phi$(y)) $\equiv$ z = \{x$\in$a $\big|$ $\phi$(x)\}\\\\
In questo modo non posso pi\`u creare il Paradosso di \textit{Russell}.\\\\
Al momento questa teoria dei tipi non \`e utilizzata. Una sua evoluzione diretta \`e 
la teoria dei tipi di \textit{Martin-L$\ddot{o}$f}.\\\\
L'idea di \textit{Russell} fu dunque quella di costruire insiemi partendo da una gerarchia.

\section{Idee principali nelle teorie di tipo moderne}
\label{sec:idee-teorie-moderne}
Le teorie di tipo moderne (chiamate $\lambda$-calcolo tipato) nascono, nel corso degli anni '30, dalla combinazione della teoria di tipo di \textit{Russell} con il $\lambda$-calcolo di \textit{Church}.

\subsection{Richiamo della teoria del $\lambda$-calcolo di \textit{Church}}
\label{subsec:lambda-calcolo}
Ha origine dalla logica, \`e un linguaggio in grado di trattare le funzioni e rivolto alla loro formalizzazione. Consiste in un linguaggio formale, le cui componenti principali sono programmi chiamati termini (pensati come funzioni).\\ La grammatica \`e la seguente:
\begin{center} t $:=$ x $|$ b$_1$(b$_2$) $|$ $\lambda$x.t \end{center}
Esempio di applicazione: tg(x) $\equiv$ $\lambda$x.tg(x)

\paragraph{Regole di computazione di base}\mbox{}\\\\ 
\[ (\lambda x.t)(b) \rightarrow t[\frac{x}{b}] \qquad
\frac{b_1 \rightarrow b_2	\qquad a_1 \rightarrow a_2 }{b_1(a_1) \rightarrow b_2(a_2)} \qquad 
\frac{b_1 \rightarrow b_2}{\lambda x.b_1 \rightarrow \lambda x.b_2} \]
\noindent
Si dice che un programma si riduca a un altro, cio\`e converge, solo se c'\`e una sequenza di riduzioni (applicazione di regole e/o assiomi), che connettono il primo programma con l'ultimo. Si parla, in questo modo, di \textbf{chiusura transitiva e simmetrica}, che si conclude quando il programma non \`e pi\`u riducibile. Quanto appena descritto pu\`o venire espresso nel seguente modo:\\\\ $t \rightarrow t'$ sse esiste un numero finito di passi per cui $t$ si riduce a $t'$, ovvero esiste $b_1 \dots b_m$ t.c. $t \rightarrow b_1 \rightarrow b_2 \dots \rightarrow b_m \rightarrow t'$.\\\\
Il $\lambda$ calcolo permette di codificare qualsiasi programma scritto in qualunque linguaggio (imperativo, dichiarativo, Java, C++, BASIC, \dots). Tuttavia tale linguaggio non codifica solo programmi che terminano, ma anche programmi che non lo fanno.
Un esempio di applicazione, per quest'ultima categoria, \`e un programma con computazione infinita: $\lambda x.x(x)$\\
$\lambda x.x(x)$ lo applichiamo a se stesso. Perci\'o diventa $\Lambda \equiv (\lambda x.x(x))(\lambda x.x(x))$
che seguendo la computazione si riduce a: \[x(x)[\frac{x}{\lambda x.x(x)}] \equiv (\lambda x.x(x))(\lambda x.x(x))\]\\
Dunque esiste una catena di (t$_i$)$_{i\in\mathbb{N}}$ di termini t$_i \rightarrow$ t$_{i+1}$. Ci\`o significa che
$\Lambda$ non termina in qualunque linguaggio sia interpretato.\\\\
$\Lambda$ risulta un buon metodo per rappresentare le funzioni, ma non \`e completo, rispetto all'intuizione matematica di funzione. \`E necessario, per questo, tipare le variabili; ovvero $\lambda$x.x$\in$A$\rightarrow$B(x$\in$A).\\\\
Il $\lambda$-cacolo tipato, nato dal $\lambda$-calcolo "puro", \`e anch'esso un linguaggio di programmazione. Essendo tipato pu\`o essere trattato come una teoria degli insiemi.

\section{Che cosa \`e un tipo?}
\label{sec:cosa e un tipo}
Per rispondere a questa domanda \`e necessario fornire la semantica intuitiva di tipo. Per farlo \`e utile pensare alla teoria dei tipi come paradigma di fondazione sia logico che matematico che informatico.

\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{XXXX}
\hline 
\rowcolor{orange}
{\color[HTML]{FFFFFF}\textbf{Sintassi in teoria dei tipi moderna}} & {\color[HTML]{FFFFFF}\textbf{Sintassi in teoria degli insiemi}} & {\color[HTML]{FFFFFF} \textbf{Sintassi in un linguaggio logico/per una logica (anche predicativo)}} & {\color[HTML]{FFFFFF}\textbf{Sintassi in un linguaggio di programmazione}} \\
\hline\hline 
A type & A set & A prop & A data type \\ 
\hline 
a$\in$A & a$\in$A set & a$\in$A & a$\in$A \\ 
\hline 
\end{tabularx}
\caption{\label{tab:sintassi-paradigmi-funzionali}Sintassi per i diversi paradigmi funzionali.} 
\end{table}
\noindent
Per la sintassi:
\begin{itemize} 
\item nella \textbf{teoria dei tipi moderna} \textit{a} rappresenta un termine e \textit{A} un tipo;
\item nella sintassi in una \textbf{teoria degli insiemi} \textit{a} \`e un elemento e \textit{A} un insieme. Coincidendo con la corrispondenza originale in mente da \textit{Russell}.
\item nella sitassi in un \textbf{linguaggio logico} \textit{a} rappresenta una proposizione di \textit{A}, inteso come insieme di tipo delle sue dimostrazioni. Perci\`o un \textit{proof-term} affermante come la proposizione di A sia vera.
\item nella teoria in una sintassi di un \textbf{linguaggio di programmazione} \textit{a} rappresenta un programma e \textit{A} una specifica.
\end{itemize}
\noindent
Dunque quando parliamo di tipo ci riferiamo a un insieme, una proposizione o \textit{data type}, a seconda dell'applicazione di tipo che si ha in mente.\\\\
Dal punto di vista logico non si hanno solo proposizioni, ma anche predicati. Parlare solo di tipo non risulta quindi sufficiente. Per questo se si vuole rappresentare non una proposizione, ma un predicato A(x) si usa la seguente sitassi: \textbf{A(x) prop[x$\in$D]}.\\
Dalla logica si sa che i predicati $\phi$(x) hanno x senza un dominio specifico, perch\`e la sintasssi non determina che cosa \`e in x. Al seguito di tutto questo i predicati hanno una variabile che deve essere tipata come \textbf{$\phi$(x) prop[x$\in$D]}.\\
Dunque (definizione di predicato)
\begin{center}\textbf{$\exists$ z $\quad$ z=\{x$\in$ a$|$ $\phi$(x)\} $\qquad$ $\equiv$ $\qquad$ $\phi$(x)prop[x$\in$ a]}\end{center}
\noindent
Quanto appena definito da origine al concetto di \textbf{tipo dipendente}, nel quale vengono tipate tutte le variabili che appartengono ad una \textbf{famiglia di tipo}.\\\\
Le famiglie di tipo sono indispensabili per rappresentare il concetto di predicato. Di seguito ho riassunto in forma tabellare le diverse famiglie.\\

\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{XXXp{3.1cm}}
\hline 
\rowcolor{orange}
{\color[HTML]{FFFFFF}\textbf{di tipo}} & {\color[HTML]{FFFFFF}\textbf{negli insiemi}} & {\color[HTML]{FFFFFF} \textbf{in logica}} & {\color[HTML]{FFFFFF}\textbf{dati dipendenti}} \\
\hline\hline 
A(x) prop[x$\in$D] & A(x) set[x$\in$D] & A(x) prop[x$\in$D] & A(x) datatype[x$\in$D]  \\  
\hline 
\end{tabularx}
\caption{\label{tab:famiglia-di-tipi}Famiglia di tipi.} 
\end{table}
\noindent
Il concetto di tipo dipendente \`e stato introdotto per la prima volta da \textit{Martin-L$\ddot{o}$f}. \textit{Russell} si era limitato a definire esclusivamente il concetto di funzione proposizionale dipendente da un tipo.
\newpage
\section{Esempi di tipi}
\label{sec:esempi-di-tipi}
\begin{table}[h]
\centering
\begin{tabularx}{\textwidth}{XXXX}
\hline 
\rowcolor{orange}
{\color[HTML]{FFFFFF}\textbf{A type}} & {\color[HTML]{FFFFFF}\textbf{A set}} & {\color[HTML]{FFFFFF} \textbf{A prop}} & {\color[HTML]{FFFFFF}\textbf{A data type}} \\
\hline\hline 
N$_1$ singoletto & l'insieme singoletto & \textit{tt} costante vero & tipo Unit  \\
\hline 
N$_0$ vuoto & l'insieme vuoto & \textit{$\bot$} costante falso & vuoto come datatype \\
\hline
BxC (tipo prodotto) & l'insieme prodotto cartesiano dell'insieme B con l'insieme C & B\&C congiunzione della proposizione B e della proposizione C & tipo prodotto cartesiamo (come in \textit{set theory})\\ 
\hline 
B+C (tipo somma binaria) & l'insieme unione disgiunta dell'insieme B con l'insieme C & B$\lor$C disgiunta della  proposizione B e della proposizione C & tipo unione disgiunta con codifica \\
\hline 
B$\rightarrow$C & l'insieme delle funzioni dall'insieme B verso l'insieme C: \small{A$\rightarrow$B $\equiv$ \{f $|$ f: B$\rightarrow$C\}} & B$\rightarrow$C, implicazione della proposizone B e della proposizione C & insieme delle funzioni dal \textit{datatype} B al \textit{datatype} C \\
\hline
\end{tabularx}
\caption{\label{tab:famiglia-di-tipi}Famiglia di tipi.} 
\end{table}
\noindent

\subsection{I tipi dipendenti}
\label{subsec:i-tipi-dipendenti}

\begin{table}[h]
\centering
\begin{tabular}{c}
\hline 
\rowcolor{orange}
{\color[HTML]{FFFFFF}\textbf{A(x)type[x$\in$B]}}\\
\hline\hline
\begin{tabular}[c]{cc}tipo indiciato\\ 
$\displaystyle\prod\limits_{x\epsilon B} C(x)$\end{tabular}\\
\hline
\begin{tabular}[c]{cc}tipo somma disgiunta indiciata \\ $\displaystyle\sum\limits_{x\epsilon B} C(x)$ \end{tabular}\\
\hline
\end{tabular}
\end{table}
\noindent

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{p{3.8cm}XX}
\hline 
\rowcolor{orange}
{\color[HTML]{FFFFFF}\textbf{A(x)set[x$\in$B]}} & {\color[HTML]{FFFFFF} \textbf{A(x)prop[x$\in$B]}} & {\color[HTML]{FFFFFF}\textbf{A(x)datatype[x$\in$B]}}\\
\hline\hline
\centering \scriptsize{\{$\displaystyle f: B \rightarrow \displaystyle\coprod\limits_{x \epsilon B} C(x)$\}} \scriptsize{$\displaystyle\coprod\limits_{x \epsilon B} C(x) =$ \{$b,c | b\epsilon B \quad c\epsilon C(b)$\}}& \centering \small{$\displaystyle \forall {x \epsilon B} \quad C(x)$} & tipo prodotto indiciato come in \textit{set theory} (non esiste un \textit{data-type} specifico)\\
\hline
\centering \scriptsize{$\displaystyle\bigcup\limits_{x \epsilon B}^. C(x)$} \qquad \qquad \qquad \scriptsize{$\displaystyle\coprod\limits_{x \epsilon B} C(x) =$ \{$b,c | b\epsilon B \quad c\epsilon C(b)$\}} & \centering \small{$\displaystyle \exists{x \epsilon B} \quad C(x)$} & non \`e primitivo deriva sempre dalla \textit{set theory}\\
\end{tabularx}
\caption{\label{tab:tipi-dipendenti}Tipi dipendenti.} 
\end{table}
\noindent
Lo slogan principale della teoria dei tipi \`e quello di tipare le variabili in un linguaggio formale set teorico/computazionale.\\\\
Esite anche il \textbf{tipo uguaglianza}:
\begin{itemize}
\item intensionale: Id(B,c,d);
\item estensionale: Eq(B,c,d).
\end{itemize}
\noindent
Introdotte da \textit{Martin-L$\ddot{o}$f}.\\
E i costrutti degli \textbf{universi}, in cui U \`e universo di proposizioni e di insiemi.
\section{Regole paradigmatiche per caratterizzare la teoria dei tipi}
\label{sec:prime-regole-teoria-dei-tipi}
La teoria dei tipi \`e stata formalizzata usando la nozione di \textbf{giudizio}, dove si asserisce qualcosa come vero.\\
Ci sono quattro forme di giudizio (nelle quali $\Gamma$ identifica il contesto):
\begin{itemize}
\item \textbf{A type[$\Gamma$]}: A \`e un tipo, possibilmente indicato da variabili nel contesto $\Gamma$, dipendente da $\Gamma$ stesso. Rappresenta il giudizio di tipo.
\item \textbf{A = B type[$\Gamma$]}: il tipo A dipendente da $\Gamma$ \`e uguale al tipo B dipendente da $\Gamma$. Rappresenta il giudizio di uguaglianza di tipo.
\item \textbf{a $\in$ A type[$\Gamma$]}: a \`e un elemento del tipo A, possibilmente indiciato, ovvero dipendente da $\Gamma$ e dalle sue variabili di contesto. Un esempio di tipo dipendente \`e l'array, che ha termini di funzioni che dipendono da $\Gamma$. Invece il termine non \`e dipendente quando si parla di funzione costante senza variabili.
\item \textbf{a = b $\in$ A type[$\Gamma$]}: a come elemento del tipo A dipende da $\Gamma$ ed \`e uguale in modo definizionale/computazionale al termine b. Quest'ultimo, difatti, \`e elemento del tipo A dipendente da $\Gamma$.
\end{itemize}
\noindent
All'interno di ogni singolo giudizio si lavora con la teoria dei tipi.\\
I giudizi solo esclusivamente asserzioni, dicono solo qualcosa quando \`e vero (non si usano i quantificatori). Essi limitano le frasi che si possono fare per codificare la logica intuizionistica. 
\subsection{Simbolo $\in$}
\label{subsec:simbolo-appartiene}
Il significato di a$\in$A in teoria dei tipi \`e differente da quello insiemistico. Espongo il concetto con un esempio trattato a lezione:
\begin{equation}
1 \in Nat \label{esempio-eq:appartiene}
\end{equation}


\begin{itemize}
\item In \textbf{\textit{set theory}} usuale $\in$ \`e tra insiemi. Nell'equazione \ref{esempio-eq:appartiene}, 1 rappresenta lui stesso un'insieme e Nat l'insieme dei numeri Naturali.
Risulta vero che 1$\equiv$\{$\varnothing$\}, poich\`e 0 $\equiv$ $\varnothing$.
\item Invece in \textbf{teoria dei tipi} (di \textit{Martin-L$\ddot{o}$f} come di \textit{Russell})
1 rappresenta un elemento ma non un tipo e Nat il tipo dei Naturali. Vi \`e dunque la distinzione tra elemento e tipo (come esiste quella tra programmi e tipi).
\end{itemize}
\subsection{Uguaglianza definizionale vs uguaglianza proposizionale}
\label{subsec:uguaglianza-computazionale-proposizionale}
Specifico \textbf{a = b$\in$ A[$\Gamma$]} come l'uguaglianza computazionale/definizionale, che viene data come primitiva e non va confusa con l'uguaglianza proposizionale/estensionale tra a e b.\\L'uguaglianza proposizionale a = b \`e rappresentata non da un giudizio, che asserisce solo ci\`o che \`e vero, ma bens\`i da un tipo Eq(A,a,b) che pu\`o anche essere senza termini e/o essere falso, dal punto di vista logico.\\\\
Visti come programmi, a e b rappresentano lo stesso programma. In $\lambda$-calcolo a$\rightarrow$b oppure b$\rightarrow$a (si riducono). Inoltre a e b possono essere sia termini finali che trovarsi in mezzo alla computazione.
\subsection{Generazione di contesti}
\label{subsec:generazione-di-contesti}
Esiste anche un quinto giudizio ausiliario (\$ \ref{subsec:formazione-contesti}) \textit{F-C}, che permette di generare i contesti. Tale giudizio, a differenza dei primi quattro, rimane immutato in ogni teoria dei tipi.

\chapter{Regole della teoria dei tipi}
\label{cap:regole-teoria-dei-tipi}
%%dalla lezione 7 alla lezione 11
Lo scopo della teoria dei tipi \`e offrire un sistema formale in cui derivare, tramite regole e assiomi, giudizi nella forma:
\[ A \hspace{0.1cm} type[\Gamma] \qquad
A = B \hspace{0.1cm} type[\Gamma] \qquad
a \in A\hspace{0.1cm} type[\Gamma] \qquad
a=b \in A \hspace{0.1cm} type [\Gamma]
\]
\[
+ \hspace{0.1cm} ausiliaria \quad \Gamma \hspace{0.1cm} cont
\]
L'ultimo giudizio non \`e necessario, serve esclusivamente per imparare.\\
Quando si formula una nuova teoria dei tipi \`e bene impiegare il minor numero possibile di regole strutturali e di formazione di tipi e termini. Tali regole devono essere rivolte all'ottimizzazione e correttezza della teoria. Alcune di queste, come quelle di indebolimento e sostituzione in \S\ref{subsec:indebolimento-sostituzione}, sono irrinunciabili, la cui validit\`a \`e sempre garantita e utilizzate nella derivazione di ogni teoria.\\\\
Se la teoria dei tipi \`e dipendente si ha bisogno di tutti i giudizi. Invece in una teoria dei tipi non dipendente, come quella dei tipi semplici, il giudizio $A = B \hspace{0.1cm} type[\Gamma]$ pu\`o venire omesso.\\

\section{Regole strutturali}
\label{sec:regole-strutturali}
Assioma unico: [\hspace{0.1cm}] cont\\\\
Nel calcolo dei sequenti, in logica classica, le derivazioni di giudizio, valide in una teoria dei tipi con solo le regole singoletto, diventano derivazioni di sequenti nella forma $\Gamma$ $\dashv$ A e unico assioma $\varphi$ $\dashv$ $\varphi$.
\\\\
Di seguito illustro le principali regole di contesto comuni a tutte le teorie dei tipi.
\subsection{Regole di formazione dei contesti}
\label{subsec:formazione-contesti}
\begin{center} [\hspace{0.1cm}] cont \quad dove [\hspace{0.1cm}] = $\varnothing$ \end{center}
\begin{prooftree}
\AxiomC{A type[$\Gamma$]}
\LeftLabel{F-C)}\RightLabel{x $\in$ A $\notin$ $\Gamma$}
\UnaryInfC{$\Gamma$, x $\in$ A}
\end{prooftree}
\subsection{Regole di assunzione delle variabili}
\label{subsec:assunzione-variabili}
\begin{prooftree}
\AxiomC{$\Gamma$, x $\in$ A, $\Delta$}
\AxiomC{cont}
\LeftLabel{var-ass)}
\BinaryInfC{x $\in$ type[$\Gamma$,x $\in$ A, $\Delta$]}
\end{prooftree}
\subsection{Regole strutturali addizionali sull'uguaglianza}
\label{subsec:uguaglianza}
L'uguaglianza, in una teoria dei tipi, consiste in una relazione di equivalenza sia fra tipi che fra termini. Sono perci\`o valide le seguenti regole di uguaglianza tra tipi:
\[ ref) \quad \frac{A\hspace{0.1cm}type[\Gamma]}{A=A\hspace{0.1cm}type[\Gamma]} \qquad sym) \quad \frac{A=B\hspace{0.1cm}type[\Gamma]}{B=A\hspace{0.1cm}type[\Gamma]} \]
\[ tra) \quad \frac{A=B\hspace{0.1cm}type[\Gamma] \qquad B=C\hspace{0.1cm}type[\Gamma]}{A=C\hspace{0.1cm}type[\Gamma]} \]
E allo stesso modo anche le regole di uguaglianza definizonale/computazionale tra termini:
\[ ref) \quad \frac{a \in A\hspace{0.1cm}type[\Gamma]}{a=a \in A\hspace{0.1cm}type[\Gamma]} \qquad sym) \quad \frac{a=b\in A \hspace{0.1cm}type[\Gamma]}{b=a \in A\hspace{0.1cm}type[\Gamma]} \]
\[ tra) \quad \frac{a=b \in A\hspace{0.1cm}type[\Gamma] \qquad b=c \in A\hspace{0.1cm}type[\Gamma]}{a=c \in A\hspace{0.1cm}type[\Gamma]} \]
\subsection{Regole di conversione dell'uguaglianza per tipi uguali}
\label{subsec:conversione-uguaglianza}
L'appartenenza si conserva con l'uguaglianza di termini e tipi. Le regole da aggiungere, in una teoria dei tipi, per garantirlo sono:
\[ conv) \quad \frac{a \in A\hspace{0.1cm}type[\Gamma] \quad A=B\hspace{0.1cm}type[\Gamma]}{a \in B\hspace{0.1cm}type[\Gamma]} \]
\[ conv-eq) \quad \frac{a=b \in A\hspace{0.1cm}type[\Gamma] \qquad A=B\hspace{0.1cm}type[\Gamma]}{a=b \in B\hspace{0.1cm}type[\Gamma]} \]
\subsection{Regole di indebolimento e di sostituzione}
\label{subsec:indebolimento-sostituzione}
\subsubsection{Indebolimento}
\label{subsec:indebolimento}
\[ ind-ty) \quad \frac{A\hspace{0.1cm}type[\Gamma] \quad \Gamma,\Delta\hspace{0.1cm}cont}{A\hspace{0.1cm}type[\Gamma,\Delta]} \quad ind-ty-eq) \quad \frac{A=B\hspace{0.1cm}type[\Gamma] \quad \Gamma,\Delta\hspace{0.1cm}cont}{A=B\hspace{0.1cm}type[\Gamma,\Delta]} \]
\[ ind-te) \quad \frac{a \in A\hspace{0.1cm}type[\Gamma] \quad \Gamma,\Delta\hspace{0.1cm}cont}{a \in A\hspace{0.1cm}type[\Gamma,\Delta]} \quad ind-te) \quad \frac{a=b \in A\hspace{0.1cm}type[\Gamma] \quad \Gamma,\Delta\hspace{0.1cm}cont}{a=b \in A\hspace{0.1cm}type[\Gamma,\Delta]} \]
\subsubsection{Sostituzione}
\label{subsec:sostituzione}
\begin{equation}
\begin{split}
C(x_1,...,x_n)\hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-typ) \quad \frac{a_1 \in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ C(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
C(x_1,...,x_n)\hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-eq-typ) \quad \frac{a_1 = b_1  \in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n = b_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ C(a_1,...,a_n) = C(b_1,...,b_n) \hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
C(x_1,...,x_n) = D(x_1,...,x_n) \hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-Eqtyp) \quad \frac{a_1 \in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ C(a_1,...,a_n) = D(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
C(x_1,...,x_n) = D(x_1,...,x_n) \hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-eq-Eqtyp) \quad \frac{a_1 = b_1\in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n = b_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ C(a_1,...,a_n) = D(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
c(x_1,...,x_n) \in C(x_1,...,x_n) \hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-ter) \quad \frac{a_1 in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ c(a_1,...,a_n) \in C(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
c(x_1,...,x_n) = d(x_1,...,x_n)  \in C(x_1,...,x_n) \hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-eqter) \quad \frac{a_1 \in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ c(a_1,...,a_n) = d(a_1,...,a_n) \in C(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
c(x_1,...,x_n) \in C(x_1,...,x_n) \hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-eq-ter) \quad \frac{a_1 = b_1 \in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n = b_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ c(a_1,...,a_n) = c(b_1,...,b_n) \in C(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
c(x_1,...,x_n) = d(x_1,...,x_n) \in C(x_1,...,x_n) \hspace{0.1cm}type[\Gamma, x_1 \in A_1,...,x_n \in A_n(x_1,...,x_{n-1})] \\ sub-eq-eqter) \quad \frac{a_1 = b_1 \in A_1\hspace{0.1cm}type[\Gamma]\hspace{0.1cm}...a_n = b_n \in A_n(a_1,...,a_{n-1})\hspace{0.1cm}type[\Gamma]}{ c(a_1,...,a_n) = d(b_1,...,b_n) \in C(a_1,...,a_n)\hspace{0.1cm}type[\Gamma]}
\end{split}
\end{equation}

\subsection{Regole proprie e derivabili}
\label{subsec:regole-proprie-derivabili}
In una teoria formale ci sono due tipi di regole:
\begin{itemize}
\item \textbf{regole proprie del calcolo}, come lo sono le regole strutturali e quelle del singoletto;
\item \textbf{regole derivabili}, come le regole di sostituzione, utili per abbreviare le derivazioni.
\end{itemize}
\noindent
Una regola r $\frac{J_1,...,J_n}{J}$ \`e ammissibile in un calcolo t sse i giudizi derivabili in $t+r$ sono gli stessi dei giudizi derivabili in t. Ci\`o comporta che l'aggiunta di una regola rt non cambia i giudizi che ne possono derivare.\\ Quando un assioma \`e ammissibili e derivabile questo coincide con un giudizio derivabile.

\subsection{Nozione di contesto telescopico}
\label{subsec:contesto-telescopico}
Un giudizio, in teoria dei tipi dipendenti si esprime nella forma
\[A(x_1,...,x_n)[x_1 \in B_1,...,x_n \in B_n]\]
e prende il nome di \textbf{contesto telescopico}.
Questi presenta una dipendenza continua, esemplificata nel seguente giudizio
\[A(x_1,x_2,x_3)\hspace{0.1cm}type[x \in C_1, x_2 \in C(x_1), x_3 \in C(x_1 x_2)..)\]
Inoltre si parla di contesti rigidi, ovvero senza possibilit\`a di scambio. Come appare dall'esempio sotto. \\
$[x \in Nat, y \in Nat, z \in Mat(x,y)]$ cont  $\Rightarrow$ \textbf{\`e derivabile}\\
$[y \in Nat, x \in Nat, z \in Mat(x,y)]$ cont $\Rightarrow$ \textbf{\`e derivabile}\\
$[y \in Nat, z \in Mat(x,y), x \in Nat]$ $\Rightarrow$ \textbf{non \`e un contesto}. \\\\ Percui non esiste lo scambio arbitrario, si deve porre attenzione alle dipendenza delle assunzioni, che provoca una sostituzione rigida.
\subsection{Esempi di applicazione}
\label{subsec:esempi-di-applicazione}
Attenzione all'ordine di sostituzione si deve partire sempre da quello con meno dipendenze.
\begin{prooftree}
\AxiomC{c $\in$ [C, $\Gamma$]}
\AxiomC{b $\in$ [B(c), $\Gamma]$}
\AxiomC{A(x,y) type[x $\in$ C, y $\in$ B(x)]}
\TrinaryInfC{A(c,b) type$[\Gamma]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{c $\in$ [C,$\Gamma$]}
\AxiomC{b $\in$ [B(c),$\Gamma]$}
\AxiomC{A(x,y) type[x $\in$ C, y $\in$ B(x)]}
\TrinaryInfC{a(c,b) $\in$ A(c,b) type$[\Gamma]$}
\end{prooftree}
Se si ha un tipo puo' venire usato il giudizio di uguaglianza tra termini e la sostituzione.
\begin{prooftree}
\AxiomC{A(x) type[$\Gamma$, x $\in$ C]}
\AxiomC{c = e $\in$ C[$\Gamma$]}
\BinaryInfC{A(c) = A(e) type[$\Gamma$]}
\end{prooftree}
\noindent
\`E dunque fondamentale il concetto di uguaglianza fra tipi. Se considero che ci sia un elemento

\begin{prooftree}
\AxiomC{a(x) $\in$ A(x) type[$\Gamma$, x $\in$ C]}
\AxiomC{c = e $\in$ C[$\Gamma$]}
\BinaryInfC{a(c) = a(e) $\in$ A(c) type[$\Gamma$]}
\end{prooftree}
\noindent
Per poter affermare che A(e) = A(c) devo poterlo dedurre. Per farlo mi sono indispensabili le \textbf{regole di conversione dell'uguaglianza del tipaggio (\S\ref{subsec:regole-tipaggio})}.

\subsection{Regole di tipaggio}
\label{subsec:regole-tipaggio}

\subsubsection{Regole di conversione}
\label{subsubsec:regole-di-conversione}
\[\frac{c \in C[\Gamma] \qquad C = D\hspace{0.1cm}type[\Gamma]}{C \in D\hspace{0.1cm}type [\Gamma]}\]
Se due tipi sono uguali allora hanno gli stessi termini: $C=D \Rightarrow (c \in C \Leftrightarrow c \in D)$. L'uguaglianza fra tipi \`e per questo simmetrica.\\
Tuttavia non sempre l'unicit\`a del tipaggio di un termine (il $\Leftrightarrow$) \`e garantito per ogni teoria. Nei casi trattati dal corso s\`i, in quanto verr\`a inteso che $C = D\hspace{0.1cm}type[\Gamma]$ sse due tipi hanno gli stessi elementi (come gi\`a accade in \textit{set theory}), ma pu\`o non essere sempre vero.

\subsubsection{Regole di conversione dell'uguaglianza}
\label{subsubsec:regole-di-conversione-uguaglianza}
\[\frac{c=d \in C[\Gamma] \qquad C = D\hspace{0.1cm}type[\Gamma]}{c = d \in D \hspace{0.1cm} type [\Gamma]}\]
Questa regola permette di convertire le uguaglianze nel tipaggio di un termine.


\section{Il tipo singoletto}
\label{sec:tipo-singoletto}
Il tipo singoletto risulta essere paradigmatico per gli altri tipi. Per definirlo impiegher\`o i giudizi nella forma $A\hspace{0.1cm}type[\Gamma]$, $a \in A\hspace{0.1cm}type[\Gamma]$ e $a = b \in A\hspace{0.1cm}type[\Gamma]$. L'uguaglianza, invece, non verr\`a coinvolta, in quanto non pu\`o essere impiegata per definire un nuovo tipo, \`e difatti usata solo nelle derivazioni.\\\\
Innanzitutto come gi\`a visto in \S\ref{subsec:formazione-contesti} ogni derivazione parte sempre dal contesto vuoto ($\varnothing$).
\begin{prooftree}
\AxiomC{A type[$\Gamma$]}
\LeftLabel{F-C)}\RightLabel{x $\in$ A $\notin$ $\Gamma$}
\UnaryInfC{$\Gamma$, x $\in$ A}
\end{prooftree}

\subsection{Regola di formazione}
\label{subsec:formazione}
\begin{prooftree}
\AxiomC{[$\Gamma$] cont}
\LeftLabel{F-S)}
\UnaryInfC{$N_1$ type[$\Gamma]$ cont}
\end{prooftree}
\textit{La regola F-S Permette di derivare vari giudizi e di dire che cosa \`e un tipo.}\\\\
Con l'impiego solo delle regole \textit{F-C} e \textit{F-S} si possono derivare [$x_1$ $\in$ $N_1$... $x_n$ $\in$ $N_1$] cont e ottenere, cos\`i, contesti di una lista arbitraria di variabili diverse appartenenti a $N_1$, come si vede dall'esempio seguente.
\begin{prooftree}
\AxiomC{[ ] cont}
\LeftLabel{\scriptsize{F-S)}}
\LeftLabel{\scriptsize{F-C)}}\RightLabel{\scriptsize{$x_1$ $\in$ $N_1$ $\notin$ $\varnothing$}}
\UnaryInfC{[$x_1$ $\in$ $N_1$] cont}
\LeftLabel{\scriptsize{F-S)}}
\UnaryInfC{$N_1$ type [$x_1$ $\in$ $N_1$]}
\LeftLabel{\scriptsize{F-C)}}\RightLabel{\scriptsize{$x_2$ $\in$ $N_1$ $\notin$ $x_1$ $\in$ $N_1$}}
\UnaryInfC{[$x_1$ $\in$ $N_1$, $x_2$ $\in$ $N_1$] cont}
\end{prooftree}

\subsection{Regole di Introduzione}
\label{subsec:introduzione}
\begin{prooftree}
\AxiomC{[$\Gamma$] cont}
\LeftLabel{I-S)}
\UnaryInfC{* $\in$ $N_1$ type[$\Gamma]$ cont}
\end{prooftree}
\textit{Sia $N_1$ in ogni contesto $\Gamma$, partendo da contesto $\varnothing$, la regola I-S permette di formare i termini, per mezzo dell'introduzione di un elemento costante * in $N_1$.}\\\\
Un esempio diretto della sua applicazione \`e
\begin{prooftree}
\AxiomC{[ ] cont}
\LeftLabel{I-S)}
\UnaryInfC{* $\in$ $N_1$ ($x_1$ $\in$ $N_1$...$x_n$ $\in$ $N_1$)}
\end{prooftree}

\subsection{Regole di Eliminazione}
\label{subsec:eliminazione}
\begin{prooftree}
\AxiomC{t $\in$ $N_1$ type[$\Gamma$]}
\AxiomC{M(z) type[$\Gamma$, z $\in$ $N_1$]}
\AxiomC{c  $\in$ M(*) type[$\Gamma$]}
\LeftLabel{E-S)}
\TrinaryInfC{$El_{N1}$(t, c) $\in$ M(*) type[$\Gamma$]}
\end{prooftree}
\noindent
\textit{El trattasi di costruttore di funzioni e $M[t] = M(z)[\frac{z}{t}]$.}
\\
La regola di eliminazione si pu\`o equivalentemente scrivere in un altro modo
\begin{prooftree}
\AxiomC{M(z) type[$\Gamma$, z $\in$ $N_1$]}
\AxiomC{c  $\in$ M(*) type[$\Gamma$]}
\LeftLabel{E-S)$_{dip}$}
\BinaryInfC{$El_{N1}$(z, c) $\in$ M(z) type[$\Gamma$, z $\in$ $N_1$]}
\end{prooftree}
Le regole \textit{E-S)$_{dip}$} + \textit{la regole di sostituzione} + \textit{F-S} + \textit{I-S} permettono di verificare la validit\`a di \textit{E-S}.
\begin{prooftree}
\AxiomC{t $\in$ $N_1$ type[$\Gamma$]}
\AxiomC{M(z) type[$\Gamma$, z $\in$ $N_1$]}
\AxiomC{c $\in$ M(*) type[$\Gamma$]}
\LeftLabel{E-S)$_{dip}$}
\BinaryInfC{$El_{N1}$(z, c) $\in$ M(z) type[$\Gamma$]}
\LeftLabel{sost)}
\BinaryInfC{$El_{N1}$(t, c) $\in$ M(t) type[$\Gamma$]}
\end{prooftree}
\noindent
Inoltre vale anche il viceversa, da \textit{E-S} si riesce a ottenere \textit{E-S$_{dip}$}.
\subsection{Regole di Conversione}
\label{subsec:conversione}
\begin{prooftree}
\AxiomC{M(z) type[$\Gamma$, z $\in$ $N_1$]}
\AxiomC{c $\in$ M(*) type[$\Gamma$]}
\LeftLabel{C-S)}
\BinaryInfC{$El_{N1}$(*, c) = c $\in$ M(*) type[$\Gamma$]}
\end{prooftree}
\textit{La conversione rende possibile l'applicazione della regola di eliminazione introducendo delle uguaglianze.}
\\\\
Le regole \textit{(S), (I-S), (E-S)} e \textit{(C-S)}  hanno una spiegazione computazionale, e riguardano la compatibilit\`a tra tipi, ma non da caratterizzare il tipo dei tipi.\\ Inoltre il tipo singoletto non \`e dipendente.
\subsection{Osservazioni sul tipo singoletto}
\label{subsec:osservazioni}
L'eliminatore El$_{N1}$(z, c) rappresenta una funzione definita per ricorsione su N$_1$, difatti in \textit{C-S} si ha che El$_{N1}$(z, c)[$\frac{z}{*}$] = El$_{N1}$(*, c).\\
Supposto che se * $\in$ N$_1$[$\Gamma$] in \textit{E-S}, allora per la singola conversione vale che El$_{N1}$ = c $\in$ M(*).
Dunque El$_{N1}$(z, c) rappresenta un programma funzionale per ricorsione. Questi \`e definito su N$_1$, a partire da c $\in$ M(*), perci\`o El$_{N1}$(*, c) = c.\\
La regola di eliminazione permette di definire un programma funzionale da N$_1$ a M(z) esclusivamente con c $\in$ M(*), ovvero definendo * come \textbf{elemento canonico}.
\\\\
In \begin{prooftree}
\AxiomC{t $\in$ N$_1$[$\Gamma$]}
\UnaryInfC{t = * $\in$ N$_1$[$\Gamma$]}
\end{prooftree}
risulta vera l'uguaglianza definizionale?\\
No, non \`e vera. La regola di eliminazione consente di dare un valore al termine canonico, permettendo cos\`i di attribuire un valore a tutti i possibili termini del singoletto. Ma in generale questo non vale all'interno della teoria. Difatti l'uguaglianza definizionale \`e diversa da quella matematica e va intesa come computazionale e non proposizionale (come definito in \S \ref{subsec:uguaglianza-computazionale-proposizionale}).

\section{Sanitary checks rules}
\label{sec:sanitary-checks}
Le \textit{Sanitary checks} sono regole strutturali utili per abbreviare le derivazioni. Queste sono derivabili solo se la teoria dei tipi \`e corretta.\\\\
\noindent
Assumento \textit{T}, come una teoria dei tipi di riferimento, le \textit{sanitary checks} sono le seguenti:
\begin{prooftree}
\AxiomC{[$\Gamma$, $\Delta$] cont}
\UnaryInfC{$\Gamma$ cont}
\end{prooftree}
Se [$\Gamma$, $\Delta$] cont \`e derivabile in \textit{T} allora anche [$\Gamma$] cont \`e derivabile in \textit{T}.
\begin{prooftree}
\AxiomC{J$_1$,...,J$_n$}
\UnaryInfC{J}
\end{prooftree}
Se J$_i$ con i = 1,...,n in \textit{T} sono derivabili allora anche J \`e derivabile in \textit{T}.
\begin{prooftree}
\AxiomC{A type [$\Gamma$]}
\UnaryInfC{$\Gamma$ cont}
\end{prooftree}
Se A type [$\Gamma$] \`e derivabile in \textit{T} allora anche $\Gamma$ cont \`e derivabile in \textit{T}.
\begin{center}
\AxiomC{A = B type [$\Gamma$]}
\UnaryInfC{A type[$\Gamma$]}
\DisplayProof
\AxiomC{A = B type [$\Gamma$]}
\UnaryInfC{B type[$\Gamma$]}
\DisplayProof
\end{center}
Se A = B type [$\Gamma$] \`e derivabile in \textit{T} allora anche A type[$\Gamma$] e B type[$\Gamma$] sono derivabili in \textit{T}.
\begin{prooftree}
\AxiomC{a $\in$ A type [$\Gamma$]}
\UnaryInfC{A type[$\Gamma$]}
\end{prooftree}
Se a $\in$ A type [$\Gamma$] \`e derivabile in \textit{T} allora anche A type[$\Gamma$] \`e derivabile in \textit{T}.
\begin{center}
\AxiomC{a = b $\in$ A type [$\Gamma$]}
\UnaryInfC{a $\in$ A type[$\Gamma$]}
\DisplayProof
\AxiomC{a = b $\in$ A type [$\Gamma$]}
\UnaryInfC{b $\in$ A type[$\Gamma$]}
\DisplayProof
\end{center}
Se a = b $\in$ A type [$\Gamma$] \`e derivabile in \textit{T} allora anche a $\in$ A type[$\Gamma$] e b $\in$ A type[$\Gamma$] sono  derivabili in \textit{T}.
\section{Esercizi}
\label{sec:esercizi-cap2}
\textbf{Dimostrare che da \textit{E-S} si riesce a ottenere \textit{E-S$_{dip}$} usando le derivazioni.}\\\\
\textbf{Dimostrare che la regola \textit{E-S} \`e derivabile in una teoria dei tipi \textit{T$_1$}, rimpiazzando la regola di eliminazione \textit{E-S} con la regola \textit{E-N${_1prog}$}, con aggiunta delle regole di indebolimento, sostituzione e di \textit{sanitary checks}}.
\begin{prooftree}
\AxiomC{M(w) type [$\Gamma$, w $\in$ N$_1$]}
\AxiomC{d $\in$ D(*) type[$\Gamma$] }
\LeftLabel{E-N$_{1prog}$)}
\BinaryInfC{EL$_N1$(w, d) $\in$ M(w) type[$\Gamma$, w $\in$ N$_1$]}
\end{prooftree}
\begin{prooftree}
\AxiomC{t` $\in$ N$_1$ type[$\sum$] }
\AxiomC{M(w) type [$\Gamma$, w $\in$ N$_1$]}
\AxiomC{d` $\in$ M(*) type[$\sum$] }
\LeftLabel{E-S)}
\TrinaryInfC{El$_{N1}$(t`, d`) $\in$ M(t`) type[$\Gamma$]}
\end{prooftree}
\textbf{Svolgimento}\\\\




%\begin{prooftree}
%\AxiomC{t $\in$ N$_1$ type[$\Gamma$] }
%\AxiomC{M(z) type [$\Gamma$, z $\in$ N$_1$]}
%\LeftLabel{E-S}
%\TrinaryInfC{El$_{N1}$(w, d) $\in$ M(w) type[$\Gamma$, w $\in$ N$_1$]}
%\end{prooftree}




































\chapter{Naturali, Somma disgiunta e liste}
%%dalla lezione 12 alle lezione 15 inclusa

\chapter{Uguaglianza proposizionale}
%% lezione 16 e 17 inclusa

\chapter{Somma indiciata forte e prodotto cartesiano}
%% lezione 17b e 19 inclusa

\chapter{Tipo delle funzioni e tipo prodotto dipendente}
%% lezione 20 e 20 addendum

\chapter{La logica della teoria dei tipi di \textit{Martin-L$\ddot{o}$f}}
%% lezione 21, 22, 23 e 24 comprese

\appendix
\chapter{Tabelle}




\end{document}